## 常用算法
   分治：分而治之，将问题拆解为形式相同子问题处理，然后合并为原问题解；
   穷举：无差别例举每一种可能解；
   迭代：不断用变量的旧值推出新值；
   回溯：按条件走，走不通就退回重新再走，回溯的核心在递归；
   贪心：将问题拆解为子问题来处理，每一步都先考虑当前最优（贪心）选择；
   动态规划：将问题拆解为子问题来处理，整理问题的最优解依赖各个子问题的最优解，自下而上求解，需要记录之前的所有局部最优解；


## 小根堆:
   new PriorityQueue<>((a, b) -> a - b)
   求 TopK或者第几大或小问题,只保留K个大小,来一个扔掉最小堆顶元素
   
## 动态规划   
   连续最值问题,连续性动态规划 dp[i]=f(dp[i-1]),迭代元素获取,要认定扫描范围是单层扫描，还是多层复合遍历
   
## 滑动窗口
   j-i=k nums[i]...nus[j]   
   
## 单调栈
   间隔元素递增或递减,前面元素先入栈和后边元素迭代比较,相邻元素,当前数组和栈顶元素比较,如括号匹配,表达式运算
   
## 队列Lwq
   约瑟夫环   
   
## 数组问题
   二分查找、快慢指针、左右指针、滑动窗口、前缀和数组、差分数组。   
   
## 前缀和
   前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和,一定是连续的 i++,j=i j++ 迭代
   
## 位运算
   异或操作,任何数和 0 异或就等于任何数,相同数异或等于 0   
   
## 差分数组
   前后元素差值,前缀和逆运算    

## 递归算法
1) 递归算法必须具有基本情况,递归出口
2) 递归算法必须向基本情况靠近
3) 递归算法必须以递归方式调用自身
4) f(x)->元素与剩下子集关系
5) 抓住核心递归实现脉络
6) 递归分解子问题有依赖递进关系,并且可以逆向推导

## 树遍历
   左右子树递归
   
## 回溯算法
   循环递归+剪枝方式试探不同路线,Backtracking(回溯)属于 DFS, 本文主要介绍算法中Backtracking算法的思想。
   回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径
   
## 贪心算法
   算法的思想: 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的
      
## 分治算法
   分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同,本质:递归   
   int left = recusive[0,i] int right = recusive[i+1,len]   
   归并排序：先递归拆分再合并两个有序子集
    
## 搜索算法
   二分法,BFS[广度遍历]，DFS[深度遍历]
   树递归遍历:findTarget(root.left,set,k) || findTarget(root.right,set,k);
   二叉树升序用中序遍历

## 奇偶校验二分法，二分法边界
   唯一数问题[奇偶校验],旋转列表[二分法边界]
   
   
## 领域算法

## 尺取算法(双指针)也称之为滑动窗口
   毛毛虫算法,就是指利用之前求出的内容与这个需要求的内容的重合部分，来尽量避免重复工作，已达到尺取（只取一点点），或者说像毛毛虫一样移动。
         其实这本质上有点类似于线性的递推（去考虑 f ( n ) f(n)f(n)与 f ( n − 1 ) f(n-1)f(n−1)的关系），
         更多的说是利用尺取的思想来避免重复工作（通常也用于优化暴力枚举），而不是单独说这个算法。
    
   
## 抽屉算法
   nums[nums[i]]=nums[i];
   
### 字符串匹配
  1)朴素算法:暴力匹配 2)模式预处理 KMP算法(不比较已经校对过的)   
  
### 大数据处理
1) 分治/hash/排序 就是先映射，而后统计，最后排序: 分而治之/hash映射: 针对数据太大，内存受限，只能是: 
     把大文件化成(取模映射)小文件，即16字方针: 大而化小，各个击破，缩小规模，逐个解决 
     hash_map统计: 当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。 
     堆/快速排序: 统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。
2) 大数据处理 - Bitmap & Bloom Filter
    布隆过滤器有着广泛的应用，对于大量数据的“存不存在”的问题在空间上有明显优势，但是在判断存不存在是有一定的错误率(false positive)，
    有可能把不属于这个集合的元素误认为属于这个集合(False Positive)，但不会把属于这个集合的元素误认为不属于这个集合(False Negative) 
3) 大数据处理 - 双层桶划分
    
### 图论
1) 迪杰斯特拉(Dijkstra)算法是贪心算法
2) 弗洛伊德(Floyd-Warshall)算法是一个经典的动态规划算法


### KNN 邻近算法
1) 推荐算法 提取相似特征，方差开根，临近求平均就是回归，分类编组，回归就是预测结果

### 机器学习
  基于大量素材提取特征训练(training)：

1) 朴素贝叶斯分类：分类算法，如：概率指标
2) 傅里叶变换：剥离离散信号
3) 线性规划：约束条件下，目标最大化

### 区块链
其实区块链技术是利用链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学来保证数据传输和访问安全、
利用自动化脚 本组成的智能合约来编程和操作数据的一种全新的分布式基础架构与计算范式
一个简单的区块包含区块头、区块体、区块哈希。
其中头包括前一个区块的哈希（pre_hash）、 当前区块交易哈希（tx_hash）、区块打包时间（time)；区块体包含所有交易（transactions）； 区块哈希（hash）是计算区块头和区块体得到的哈希值